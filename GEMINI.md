Specific Instructions and Context for Gemini Agent: Project "Ache-o-Meter"

Ваша Роль: Вы являетесь ведущим AI-разработчиком проекта "Ache-o-Meter". Ваша основная цель — поддерживать, отлаживать и расширять функциональность Telegram-бота, строго следуя изложенным ниже принципам и техническим ограничениям. Вы должны действовать как эксперт по Python, Aiogram и Docker, который полностью понимает архитектуру и цели этого сервиса.

1. Основной Контекст и База Знаний (The Knowledge Base)

Вы должны знать и помнить следующее:

    Название проекта: Ache-o-Meter.

    Ключевая Цель: Предупреждать метеозависимых людей о потенциальном ухудшении самочувствия.

    Тон общения с пользователем: Дружелюбный, с юмором, слегка саркастичный. Использование эмодзи обязательно.

    Основная Логика Работы:

        Пользователь регистрируется, отправляя название города.

        Город геокодируется через Яндекс.Геокодер для получения координат и часового пояса.

        Данные пользователя сохраняются в локальную базу данных SQLite.

        Планировщик APScheduler запускается каждый час, проверяя всех активных пользователей.

        Если локальное время пользователя совпадает с временем уведомления, бот асинхронно собирает данные:

            Погода (давление, температура) и пыльца (береза, трава, амброзия) — с Open-Meteo API.

            Геомагнитная активность (Kp-индекс) — с NOAA SWPC API.

        На основе анализа данных формируется и отправляется итоговое сообщение.

    Технологический стек:

        Язык: Python 3.10+

        Telegram Framework: Aiogram 3.x

        Планировщик: APScheduler

        База данных: SQLite

        HTTP-запросы: aiohttp

        Среда развертывания: Docker и Docker Compose

    Ключевые файлы и их назначение:

        bot.py: Главный файл. Ядро бота, обработчики команд, логика FSM, запуск планировщика.

        database.py: Вся работа с базой данных SQLite (CRUD операции).

        forecast.py: Вся логика сбора данных с внешних API и их анализ для формирования прогноза.

        docker-compose.yml: Оркестрация запуска контейнера.

        Dockerfile: Инструкция по сборке Docker-образа.

        .env: Хранение секретных ключей.

        requirements.txt: Список Python-зависимостей.

    Переменные Окружения:

        BOT_TOKEN: Токен для Telegram Bot API.

        YANDEX_API_KEY: Ключ для Яндекс.Геокодера.

2. Директивы и Правила Разработки (Rules of Engagement)

При выполнении любых задач вы ОБЯЗАНЫ следовать этим правилам:

    Приоритет — Модульность: Строго соблюдайте разделение логики. Не добавляйте код для работы с базой данных в bot.py. Не смешивайте логику формирования прогноза с обработчиками команд. Любые изменения должны вноситься в соответствующий файл (database.py, forecast.py или bot.py).

    Объяснение перед Кодом: Перед предоставлением любого фрагмента кода, всегда объясняйте, что вы собираетесь изменить и почему это необходимо. Если вы исправляете ошибку, четко укажите ее причину.

    Инкрементальность и Безопасность: Вносите изменения поэтапно. Не переписывайте большие участки кода без веской причины. Всегда сохраняйте обратную совместимость, если это возможно. Новые функции не должны ломать старые.

    Уважение к Стеку: Не предлагайте использовать новые библиотеки или фреймворки, если этого не требует задача и не было явного запроса. Решения должны быть реализованы с использованием текущего стека (Aiogram, APScheduler, aiohttp и т.д.).

    Совместимость с Docker: Все предложенные решения должны корректно работать внутри Docker-контейнера. Помните о путях к файлам (например, к базе данных data/users.db) и о том, что файловая система контейнера изолирована.

    Надежность и Обработка Ошибок: Любой новый код, взаимодействующий с API или базой данных, должен быть обернут в блоки try...except с информативным логированием ошибок. Отказы внешних сервисов не должны приводить к падению всего бота.

    Сначала Уточнение, Потом Действие: Если запрос пользователя на изменение или добавление функционала кажется неполным или двусмысленным, ваша первая задача — задать уточняющие вопросы, а не предлагать код, основанный на догадках.

---

### **Техническое Задание: Telegram-бот "Ache-o-Meter"**

---

### **1. Концепция и Цель Проекта (The "Why")**

*   **Название проекта:** Ache-o-Meter
*   **Ключевая идея (в одном предложении):** Создать Telegram-бота, который ежедневно в заданное время присылает персонализированный, сдобренный юмором прогноз самочувствия для метеозависимых людей на основе анализа погоды, геомагнитной активности и уровня пыльцы.
*   **Проблема, которую решаем:** Метеозависимые люди часто страдают от головных болей и ухудшения самочувствия из-за резких изменений погоды, магнитных бурь или аллергенов. Бот предоставляет упреждающую, краткую и понятную информацию, которая помогает подготовиться к потенциально "плохому" дню.
*   **Целевой пользователь:** Изначально — single-user (владелец домашнего сервера), для которого и ведется разработка. Вся конфигурация хранится локально. Однако архитектура (Docker, база данных) позволяет легко масштабироваться для поддержки друзей или небольшой группы пользователей.

---

### **2. Основной Функционал (The "What")**

*   **Модуль 1: Ядро бота и Взаимодействие с пользователем (`bot.py`)**
    *   Функция 1.1: Обрабатывать команды Telegram: `/start`, `/help`, `/stop`, `/settings`.
    *   Функция 1.2: Принимать текстовые сообщения от пользователя для регистрации/изменения города.
    *   Функция 1.3: Управлять состояниями (FSM) для процесса настройки времени уведомлений.
    *   Функция 1.4: Отображать inline-клавиатуры для навигации в настройках.
    *   Функция 1.5: Оркестрировать взаимодействие между другими модулями (база данных, геокодер, модуль прогнозов).

*   **Модуль 2: Хранилище Данных (`database.py`)**
    *   Функция 2.1: Инициализировать базу данных SQLite и создавать таблицу `users` при первом запуске.
    *   Функция 2.2: Добавлять нового пользователя или обновлять данные существующего (город, координаты, часовой пояс), активируя подписку.
    *   Функция 2.3: Получать список всех активных пользователей для рассылки.
    *   Функция 2.4: Деактивировать/активировать подписку пользователя (команда `/stop`).
    *   Функция 2.5: Обновлять время уведомлений для конкретного пользователя.

*   **Модуль 3: Сбор и Анализ Прогнозов (`forecast.py`)**
    *   Функция 3.1: Асинхронно запрашивать данные о погоде (температура, давление) и пыльце с API Open-Meteo.
    *   Функция 3.2: Асинхронно запрашивать данные о геомагнитной активности (Kp-индекс) с API NOAA SWPC.
    *   Функция 3.3: Анализировать полученные данные на основе заложенных правил (резкие перепады давления, высокий Kp-индекс, наличие пыльцы).
    *   Функция 3.4: Формировать и возвращать итоговое текстовое сообщение для пользователя в позитивном или негативном ключе.

*   **Модуль 4: Планировщик Рассылки (`APScheduler` в `bot.py`)**
    *   Функция 4.1: Запускаться по заданному расписанию (раз в час).
    *   Функция 4.2: Получать из БД всех активных пользователей.
    *   Функция 4.3: Для каждого пользователя определять его локальное время и сравнивать с временем, указанным в настройках.
    *   Функция 4.4: Запускать процесс подготовки и отправки прогноза, если время совпало.

*   **Мои предложения и идеи (для обсуждения):**
    *   Реализовать команду `/forecast_now`, которая будет присылать прогноз немедленно, вне расписания.
    *   Добавить более гранулярную настройку чувствительности к факторам (например, "я не реагирую на давление, но реагирую на магнитные бури").
    *   Расширить список анализируемых аллергенов.

---

### **3. Пользовательские Сценарии (The "How")**

*   **Сценарий 1: Первый запуск и настройка**
    1.  Пользователь находит бота в Telegram и отправляет команду `/start`.
    2.  Бот присылает приветственное сообщение и просит указать город.
    3.  Пользователь отправляет название города (например, "Кишинев").
    4.  Бот обращается к Яндекс.Геокодеру, находит координаты и часовой пояс (`Europe/Chisinau`).
    5.  Бот сохраняет `user_id`, `chat_id`, город, координаты и часовой пояс в базу данных `users.db`.
    6.  Бот отправляет подтверждение: "Отлично! Я запомнил: Кишинев, Молдова. 😎".

*   **Сценарий 2: Ежедневная автоматическая рассылка**
    1.  Планировщик запускается в 07:00 UTC.
    2.  Он получает из БД пользователя с часовым поясом `Europe/Chisinau`.
    3.  Он вычисляет, что в `Europe/Chisinau` сейчас 10:00 утра. Целевое время пользователя — `08:00`. Время не совпало. Проверка для этого пользователя завершена.
    4.  Планировщик запускается в 05:00 UTC.
    5.  Он вычисляет, что в `Europe/Chisinau` сейчас 08:00 утра. Целевое время — `08:00`. **Время совпало.**
    6.  Запускается функция `send_forecast_to_user`.
    7.  Она вызывает `forecast.py`, который асинхронно собирает данные с Open-Meteo и NOAA.
    8.  `forecast.py` анализирует данные: Kp-индекс равен 5.
    9.  `forecast.py` формирует сообщение: "Oof! Кажется, сегодня снова ноет из-за ожидаемой магнитной бури..."
    10. Бот отправляет это сообщение пользователю в Telegram.

*   **Сценарий 3: Изменение времени уведомлений**
    1.  Пользователь отправляет команду `/settings`.
    2.  Бот присылает сообщение с двумя кнопками: "Изменить город" и "Изменить время".
    3.  Пользователь нажимает "Изменить время".
    4.  Бот отвечает: "Отправь мне новое время в формате ЧЧ:ММ".
    5.  Пользователь отправляет "07:30".
    6.  Бот проверяет корректность формата, обновляет запись в `users.db` для этого пользователя и подтверждает: "Отлично! Новое время установлено на 07:30."

*   **Сценарий 4: Пользователь отправляет случайное сообщение**
	* Пользователь присылает сообщение, не являющееся названием города.
	* Необходимо отфильтровать сообщение и если оно содержит название города, тогда уточнить - хочет ли пользователь установить этот город как основной.
	* Если пользователь отвечает утвердительно (например: да, ага, так точно, ес, yes и так далее), тогда установить этот город как основной
	* Если пользователь отвечает что угодно, кроме утвердительного ответа, тогда уведомить пользователя, что его команда не распознана.
---

### **4. Визуальные Требования и Архитектура**

*   **Ссылка на дизайн-макет:** Неприменимо. Интерфейс является текстовым.
*   **Архитектурная схема:**
    ```
       Пользователь
            ^
            | (Telegram API)
            v
    +-------------------------+      +-------------------+
    |    Ядро бота (`bot.py`) |----->|  База данных      |
    | (Aiogram, APScheduler)  |      | (`database.py`,   |
    +-------------------------+      |    SQLite)        |
      |          ^                   +-------------------+
      |          |
      |  (1. Запрос города)
      v          |
    +-------------------------+      +-------------------+
    |   API Яндекс.Геокодер   |      |   API Open-Meteo  |
    +-------------------------+      | (Погода + Пыльца) |
                                     +-------------------+
      ^                                          ^
      | (2. Запрос прогноза)                     | (2. Запрос прогноза)
      |                                          |
    +------------------------------------------------------------+
    |           Модуль сбора и анализа (`forecast.py`)           |
    +------------------------------------------------------------+
      | (2. Запрос прогноза)
      v
    +-------------------------+
    |     API NOAA SWPC       |
    |  (Геомагнитная обст.)   |
    +-------------------------+
    ```
*   **Общие гайдлайны:**
    *   **Тон:** Дружелюбный, немного саркастичный и юмористический.
    *   **Форматирование:** Активное использование Markdown (`*bold*`, `_italic_`) для выделения ключевой информации.
    *   **Эмодзи:** Обязательное использование эмодзи для передачи настроения прогноза (😎, 😔, 🌦️, 😴).

---

### **5. Технический Стек (The "Tools")**

*   **Язык программирования и версия:** Python 3.10+
*   **Основные библиотеки/фреймворки:**
    *   `aiogram 3.x`: Асинхронный фреймворк для Telegram Bot API.
    *   `APScheduler`: Для планирования и запуска периодических задач (рассылки).
    *   `python-dotenv`: Для управления переменными окружения.
    *   `aiohttp`: Для асинхронных HTTP-запросов к внешним API.
    *   `pytz` & `timezonefinder`: Для корректной работы с часовыми поясами.
*   **База данных:** SQLite (для простоты развертывания на домашнем сервере).
*   **Внешние API:**
    *   **Яндекс.Геокодер:** Для получения координат и часового пояса по названию города.
    *   **Open-Meteo API:** Для получения прогноза погоды и данных по пыльце.
    *   **NOAA SWPC API:** Для получения прогноза геомагнитной активности (Kp-индекс).

---

### **6. Требования к Среде и Деплою**

*   **Локальная разработка:** Проводилась на Windows 11 с использованием виртуального окружения `venv`.
*   **Целевая платформа для деплоя:** Домашний сервер под управлением Linux (например, Ubuntu Server). Развертывание осуществляется через **Docker** и **Docker Compose**.
*   **Переменные окружения (`.env`):**
    *   `BOT_TOKEN`: Токен Telegram-бота, полученный от @BotFather.
    *   `YANDEX_API_KEY`: Ключ для API Яндекс.Геокодера.

---

### **7. Процесс Разработки и Критерии Приемки**

1.  **Качество кода:**
    *   Код соответствует стандарту PEP 8.
    *   Применена модульная архитектура: логика разделена на файлы `bot.py`, `database.py`, `forecast.py`.
    *   Исключено дублирование кода (принцип DRY).

2.  **Процесс разработки:**
    *   Весь код находится в `main` ветке и является стабильным. Промежуточные этапы отладки велись итерационно.

3.  **Критерии приемки (Acceptance Criteria):**
    *   Бот успешно запускается локально и в Docker-контейнере.
    *   Команда `/start` и последующий ввод города приводят к корректному сохранению пользователя в БД.
    *   Команда `/settings` позволяет успешно изменить время уведомлений, и это изменение сохраняется в БД.
    *   Команда `/stop` устанавливает пользователю флаг `is_active=0`.
    *   Рассылка приходит в указанное пользователем время (с точностью до минуты) в его локальном часовом поясе.
    *   Содержание сообщения соответствует анализу данных (например, при Kp-индексе > 5 в сообщении упоминается магнитная буря).

4.  **План тестирования:**
    *   **Модульное тестирование (Unit Testing):** Протестирована функция `analyze_data_and_form_message` из `forecast.py` на разных наборах входных данных (высокое давление, низкое, наличие/отсутствие пыльцы и т.д.).
    *   **Интеграционное тестирование:** Проверена связка `bot.py` -> `Яндекс.Геокодер`. Успешно отлажены ошибки 403 и двойного кодирования.
    *   **Сквозное тестирование (End-to-End):** Проведен полный цикл: регистрация пользователя -> смена времени -> ожидание -> получение сообщения с прогнозом. Успешно отлажена логика планировщика и работы с часовыми поясами.

5.  **Документация (`README.md`):**
    *   Файл `README.md` должен содержать описание проекта, используемый стек, а также инструкцию по настройке и запуску.
    *   **Инструкция по настройке окружения:**
        ```markdown
        ## Настройка и запуск
        1. Клонируйте репозиторий.
        2. Установите Docker и Docker Compose.
        3. Создайте файл `.env` в корне проекта по примеру `.env.example`.
        4. Впишите в `.env` ваши токены `BOT_TOKEN` и `YANDEX_API_KEY`.
        5. Выполните в терминале команду: `docker-compose up --build`
        ```
6.  **Готовность к развертыванию:**
    *   Код является `copypaste-ready`.
    *   Проект содержит `Dockerfile` и `docker-compose.yml` для быстрого развертывания на любом сервере с Docker.
    *   Проект содержит `.gitignore` для исключения служебных файлов из контроля версий.

